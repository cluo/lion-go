package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"go.pedge.io/proto/plugin"
	"go.pedge.io/protolog"

	"github.com/golang/glog"
	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"

	_ "go.pedge.io/protolog"
)

var (
	tmpl = template.Must(template.New("tmpl").Parse(`
// Code generated by protoc-gen-protolog
// source: {{.Name}}
// DO NOT EDIT!

package {{.GoPackage}}

import "go.pedge.io/protolog"

func init() {
	{{range $messageData := .MessageDatas}}{{range $messageType := $messageData.MessageTypes}}protolog.Register("{{$messageData.ProtoName}}", protolog.MessageType_{{$messageType}}, func() protolog.Message { return &{{$messageData.GoName}}{} })
{{end}}{{end}}}

{{range $messageData := .MessageDatas}}func (m *{{$messageData.GoName}}) ProtologName() string {
	return "{{$messageData.ProtoName}}"
}
{{end}}
`))
)

type tmplData struct {
	Name         string
	GoPackage    string
	MessageDatas []*tmplMessageData
}

type tmplMessageData struct {
	ProtoName    string
	MessageTypes []string
	GoName       string
}

func main() {
	flag.Parse()
	defer glog.Flush()
	if err := do(); err != nil {
		fmt.Fprintf(os.Stderr, "%s\n", err.Error())
		os.Exit(1)
	}
	os.Exit(0)
}

func do() error {
	return protoplugin.NewPlugin("pb.log.go", newGenerator(), protoplugin.PluginOptions{GoFmt: true}).Handle()
}

type generator struct{}

func newGenerator() *generator {
	return &generator{}
}

func (g *generator) Generate(fileDescriptorProto *descriptor.FileDescriptorProto) (io.Reader, error) {
	tmplData, err := getTmplData(fileDescriptorProto)
	if err != nil {
		return nil, err
	}
	if tmplData == nil {
		return nil, nil
	}
	buffer := bytes.NewBuffer(nil)
	if err := tmpl.Execute(buffer, tmplData); err != nil {
		return nil, err
	}
	return buffer, nil
}

func getTmplData(fileDescriptorProto *descriptor.FileDescriptorProto) (*tmplData, error) {
	var messageDatas []*tmplMessageData
	for _, messageType := range fileDescriptorProto.MessageType {
		var parents []string
		var err error
		messageDatas, err = getTmplMessageDatas(fileDescriptorProto.GetPackage(), parents, false, false, messageType, messageDatas)
		if err != nil {
			return nil, err
		}
	}
	if len(messageDatas) == 0 {
		return nil, nil
	}
	return &tmplData{
		Name:         fileDescriptorProto.GetName(),
		GoPackage:    getGoPackage(fileDescriptorProto),
		MessageDatas: messageDatas,
	}, nil
}

func getTmplMessageDatas(pkg string, parents []string, isEvent bool, isContext bool, messageType *descriptor.DescriptorProto, messageDatas []*tmplMessageData) ([]*tmplMessageData, error) {
	var err error
	if !isEvent {
		isEvent, err = isBoolExtension(messageType, protolog.E_Event)
		if err != nil {
			return nil, err
		}
	}
	if !isContext {
		isContext, err = isBoolExtension(messageType, protolog.E_Context)
		if err != nil {
			return nil, err
		}
	}
	if !isEvent && !isContext {
		return messageDatas, nil
	}
	protoName := pkg
	for _, parent := range parents {
		protoName = protoName + "." + parent
	}
	name := messageType.GetName()
	protoName = protoName + "." + name
	goName := name
	for i := len(parents) - 1; i >= 0; i-- {
		goName = parents[i] + "_" + goName
	}
	tmplMessageData := &tmplMessageData{
		ProtoName:    protoName,
		MessageTypes: make([]string, 0),
		GoName:       goName,
	}
	if isEvent {
		tmplMessageData.MessageTypes = append(tmplMessageData.MessageTypes, "MESSAGE_TYPE_EVENT")
	}
	if isContext {
		tmplMessageData.MessageTypes = append(tmplMessageData.MessageTypes, "MESSAGE_TYPE_CONTEXT")
	}
	messageDatas = append(messageDatas, tmplMessageData)
	for _, child := range messageType.NestedType {
		if child.Options == nil || !child.Options.GetMapEntry() {
			messageDatas, err = getTmplMessageDatas(
				pkg,
				append(parents, name),
				isEvent,
				isContext,
				child,
				messageDatas,
			)
			if err != nil {
				return nil, err
			}
		}
	}
	return messageDatas, nil
}

func getGoPackage(fileDescriptorProto *descriptor.FileDescriptorProto) string {
	if fileDescriptorProto.Options != nil && fileDescriptorProto.Options.GoPackage != nil {
		return fileDescriptorProto.Options.GetGoPackage()
	}
	if fileDescriptorProto.Package == nil {
		base := filepath.Base(fileDescriptorProto.GetName())
		ext := filepath.Ext(base)
		return strings.TrimSuffix(base, ext)
	}
	return strings.Replace(fileDescriptorProto.GetPackage(), ".", "_", -1)
}

func isBoolExtension(messageType *descriptor.DescriptorProto, extensionDesc *proto.ExtensionDesc) (bool, error) {
	if messageType.Options == nil {
		return false, nil
	}
	if !proto.HasExtension(messageType.Options, extensionDesc) {
		return false, nil
	}
	extensionObj, err := proto.GetExtension(messageType.Options, extensionDesc)
	if err != nil {
		return false, err
	}
	extension, ok := extensionObj.(*bool)
	if !ok {
		return false, fmt.Errorf("%v is not of type bool", extensionObj)
	}
	return *extension, nil
}
