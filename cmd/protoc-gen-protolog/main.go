package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	"github.com/golang/protobuf/protoc-gen-go/plugin"
)

var (
	tmpl = template.Must(template.New("tmpl").Parse(`
// Code generated by protoc-gen-protolog
// source: {{.Name}}
// DO NOT EDIT!

package {{.GoPackage}}

import "go.pedge.io/protolog"

func init() {
{{range $messageData := .MessageDatas}}protolog.Register("{{$messageData.ProtoName}}", func() protolog.Message { return &{{$messageData.GoName}}{} })
{{end}}}

{{range $messageData := .MessageDatas}}func (m *{{$messageData.GoName}}) ProtologName() string {
	return "{{$messageData.ProtoName}}"
}
{{end}}
`))
)

type tmplData struct {
	Name         string
	GoPackage    string
	MessageDatas []*tmplMessageData
}

type tmplMessageData struct {
	ProtoName string
	GoName    string
}

func main() {
	if err := do(); err != nil {
		fmt.Fprintf(os.Stderr, "%s\n", err.Error())
		os.Exit(1)
	}
	os.Exit(0)
}

func do() error {
	data, err := ioutil.ReadAll(os.Stdin)
	if err != nil {
		return err
	}
	codeGeneratorRequest := &google_protobuf_compiler.CodeGeneratorRequest{}
	if err := proto.Unmarshal(data, codeGeneratorRequest); err != nil {
		return err
	}
	if codeGeneratorRequest.Parameter != nil {
		for _, parameter := range strings.Split(codeGeneratorRequest.GetParameter(), ",") {
			split := strings.SplitN(parameter, "=", 2)
			if len(split) == 1 {
				if err := flag.CommandLine.Set(parameter, ""); err != nil {
					return err
				}
			} else {
				if err := flag.CommandLine.Set(split[0], split[1]); err != nil {
					return err
				}
			}
		}
	}
	files := make([]*google_protobuf_compiler.CodeGeneratorResponse_File, len(codeGeneratorRequest.FileToGenerate))
	for i, fileToGenerate := range codeGeneratorRequest.FileToGenerate {
		file, generateErr := generate(fileToGenerate, codeGeneratorRequest.ProtoFile)
		if generateErr != nil {
			return writeError(generateErr)
		}
		files[i] = file
	}
	return writeFiles(files)
}

func writeFiles(files []*google_protobuf_compiler.CodeGeneratorResponse_File) error {
	return writeCodeGeneratorResponse(&google_protobuf_compiler.CodeGeneratorResponse{File: files})
}

func writeError(err error) error {
	return writeCodeGeneratorResponse(&google_protobuf_compiler.CodeGeneratorResponse{Error: proto.String(err.Error())})
}

func writeCodeGeneratorResponse(codeGeneratorResponse *google_protobuf_compiler.CodeGeneratorResponse) error {
	data, err := proto.Marshal(codeGeneratorResponse)
	if err != nil {
		return err
	}
	if _, err := os.Stdout.Write(data); err != nil {
		return err
	}
	return nil
}

func generate(fileToGenerate string, protoFiles []*descriptor.FileDescriptorProto) (*google_protobuf_compiler.CodeGeneratorResponse_File, error) {
	protoFile, err := getProtoFile(fileToGenerate, protoFiles)
	if err != nil {
		return nil, err
	}
	tmplData, err := getTmplData(protoFile)
	if err != nil {
		return nil, err
	}
	buffer := bytes.NewBuffer(nil)
	if err := tmpl.Execute(buffer, tmplData); err != nil {
		return nil, err
	}
	formatted, err := format.Source(buffer.Bytes())
	if err != nil {
		return nil, err
	}
	return &google_protobuf_compiler.CodeGeneratorResponse_File{
		Name:    proto.String(getFileName(protoFile)),
		Content: proto.String(string(formatted)),
	}, nil
}

func getProtoFile(fileToGenerate string, protoFiles []*descriptor.FileDescriptorProto) (*descriptor.FileDescriptorProto, error) {
	for _, protoFile := range protoFiles {
		if protoFile.GetName() == fileToGenerate {
			return protoFile, nil
		}
	}
	return nil, fmt.Errorf("no FileDescriptorProto for %s", fileToGenerate)
}

func getTmplData(protoFile *descriptor.FileDescriptorProto) (*tmplData, error) {
	var messageDatas []*tmplMessageData
	for _, messageType := range protoFile.MessageType {
		var parents []string
		messageDatas = getTmplMessageDatas(protoFile.GetPackage(), parents, messageType, messageDatas)
	}
	return &tmplData{
		Name:         protoFile.GetName(),
		GoPackage:    getGoPackage(protoFile),
		MessageDatas: messageDatas,
	}, nil
}

func getTmplMessageDatas(pkg string, parents []string, messageType *descriptor.DescriptorProto, messageDatas []*tmplMessageData) []*tmplMessageData {
	protoName := pkg
	for _, parent := range parents {
		protoName = protoName + "." + parent
	}
	name := messageType.GetName()
	protoName = protoName + "." + name
	goName := name
	for i := len(parents) - 1; i >= 0; i-- {
		goName = parents[i] + "_" + goName
	}
	messageDatas = append(
		messageDatas,
		&tmplMessageData{
			ProtoName: protoName,
			GoName:    goName,
		},
	)
	for _, child := range messageType.NestedType {
		if child.Options == nil || !child.Options.GetMapEntry() {
			messageDatas = getTmplMessageDatas(
				pkg,
				append(parents, name),
				child,
				messageDatas,
			)
		}
	}
	return messageDatas
}

func getGoPackage(protoFile *descriptor.FileDescriptorProto) string {
	if protoFile.Options != nil && protoFile.Options.GoPackage != nil {
		return protoFile.Options.GetGoPackage()
	}
	if protoFile.Package == nil {
		base := filepath.Base(protoFile.GetName())
		ext := filepath.Ext(base)
		return strings.TrimSuffix(base, ext)
	}
	return strings.Replace(protoFile.GetPackage(), ".", "_", -1)
}

func getFileName(protoFile *descriptor.FileDescriptorProto) string {
	name := protoFile.GetName()
	return fmt.Sprintf("%s.pb.log.go", strings.TrimSuffix(name, filepath.Ext(name)))
}
