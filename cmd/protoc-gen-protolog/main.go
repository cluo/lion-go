package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"go.pedge.io/proto/plugin"
	"go.pedge.io/protolog"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
)

var (
	tmpl = template.Must(template.New("tmpl").Parse(`
// Code generated by protoc-gen-protolog
// source: {{.Name}}
// DO NOT EDIT!

package {{.GoPackage}}

import "go.pedge.io/protolog"

func init() {
{{range $messageData := .MessageDatas}}protolog.Register("{{$messageData.ProtoName}}", func() protolog.Message { return &{{$messageData.GoName}}{} })
{{end}}}

{{range $messageData := .MessageDatas}}func (m *{{$messageData.GoName}}) ProtologName() string {
	return "{{$messageData.ProtoName}}"
}
{{end}}
`))
)

type tmplData struct {
	Name         string
	GoPackage    string
	MessageDatas []*tmplMessageData
}

type tmplMessageData struct {
	ProtoName string
	GoName    string
}

func main() {
	if err := do(); err != nil {
		fmt.Fprintf(os.Stderr, "%s\n", err.Error())
		os.Exit(1)
	}
	os.Exit(0)
}

func do() error {
	return protoplugin.NewPlugin("pb.log.go", newGenerator(), protoplugin.PluginOptions{GoFmt: true}).Handle()
}

type generator struct{}

func newGenerator() *generator {
	return &generator{}
}

func (g *generator) Generate(fileDescriptorProto *descriptor.FileDescriptorProto) (io.Reader, error) {
	tmplData, err := getTmplData(fileDescriptorProto)
	if err != nil {
		return nil, err
	}
	if tmplData == nil {
		return nil, nil
	}
	buffer := bytes.NewBuffer(nil)
	if err := tmpl.Execute(buffer, tmplData); err != nil {
		return nil, err
	}
	return buffer, nil
}

func getTmplData(fileDescriptorProto *descriptor.FileDescriptorProto) (*tmplData, error) {
	var messageDatas []*tmplMessageData
	for _, messageType := range fileDescriptorProto.MessageType {
		var parents []string
		messageDatas = getTmplMessageDatas(fileDescriptorProto.GetPackage(), parents, false, messageType, messageDatas)
	}
	if len(messageDatas) == 0 {
		return nil, nil
	}
	return &tmplData{
		Name:         fileDescriptorProto.GetName(),
		GoPackage:    getGoPackage(fileDescriptorProto),
		MessageDatas: messageDatas,
	}, nil
}

func getTmplMessageDatas(pkg string, parents []string, isProtolog bool, messageType *descriptor.DescriptorProto, messageDatas []*tmplMessageData) []*tmplMessageData {
	if !isProtolog {
		isProtolog = proto.HasExtension(messageType.Options, protolog.E_Protolog)
	}
	if !isProtolog {
		return messageDatas
	}
	protoName := pkg
	for _, parent := range parents {
		protoName = protoName + "." + parent
	}
	name := messageType.GetName()
	protoName = protoName + "." + name
	goName := name
	for i := len(parents) - 1; i >= 0; i-- {
		goName = parents[i] + "_" + goName
	}
	messageDatas = append(
		messageDatas,
		&tmplMessageData{
			ProtoName: protoName,
			GoName:    goName,
		},
	)
	for _, child := range messageType.NestedType {
		if child.Options == nil || !child.Options.GetMapEntry() {
			messageDatas = getTmplMessageDatas(
				pkg,
				append(parents, name),
				isProtolog,
				child,
				messageDatas,
			)
		}
	}
	return messageDatas
}

func getGoPackage(fileDescriptorProto *descriptor.FileDescriptorProto) string {
	if fileDescriptorProto.Options != nil && fileDescriptorProto.Options.GoPackage != nil {
		return fileDescriptorProto.Options.GetGoPackage()
	}
	if fileDescriptorProto.Package == nil {
		base := filepath.Base(fileDescriptorProto.GetName())
		ext := filepath.Ext(base)
		return strings.TrimSuffix(base, ext)
	}
	return strings.Replace(fileDescriptorProto.GetPackage(), ".", "_", -1)
}
